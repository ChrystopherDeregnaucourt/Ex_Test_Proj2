 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/app/pages/home/home.component.ts b/src/app/pages/home/home.component.ts
index 882ea91c17604cf197d2940c8920941d6db181a1..b62e1717fcccbbdfb29691029daaf88e83c7d15e 100644
--- a/src/app/pages/home/home.component.ts
+++ b/src/app/pages/home/home.component.ts
@@ -1,106 +1,171 @@
 import { Component, OnInit } from '@angular/core';
 import { filter, map, Observable, of } from 'rxjs';
 import { OlympicService } from 'src/app/core/services/olympic.service';
 import { Router } from '@angular/router';
 import ChartDataLabels from 'chartjs-plugin-datalabels';
 import {
   ChartConfiguration,
   ChartData,
-  ChartType,
-  TooltipItem,
   Chart,
+  Plugin,
+  TooltipItem,
 } from 'chart.js';
 
 @Component({
     selector: 'app-home',
     templateUrl: './home.component.html',
     styleUrls: ['./home.component.scss'],
     standalone: false
 })
 export class HomeComponent implements OnInit {
   public olympics$: Observable<any> = of(null);
 
   public viewModel$: Observable<HomeViewModel> = of({
     countriesCount: 0,
     olympicsCount: 0,
     chartData: { labels: [], datasets: [] },
   });
 
   public pieChartOptions: ChartConfiguration<'pie'>['options'] = {
     responsive: true,
     maintainAspectRatio: false,
-    plugins: {
-    legend: {
-      display: false, // Cache la lÃ©gende classique
-      labels: {
-        usePointStyle: true,
-        color: '#1f2937',
-        padding: 20,
-        font: {
-          family: '"Poppins", "Segoe UI", Arial, sans-serif',
-          size: 13,
-          weight: 500,
-        },
+    layout: {
+      padding: {
+        top: 32,
+        bottom: 32,
+        left: 120,
+        right: 120,
       },
     },
-    datalabels: {
-      color: '#333',
-      font: {
-        weight: 'bold',
-        size: 12,
+    plugins: {
+      legend: {
+        display: false,
+        labels: {
+          usePointStyle: true,
+          color: '#1f2937',
+          padding: 20,
+          font: {
+            family: '"Poppins", "Segoe UI", Arial, sans-serif',
+            size: 13,
+            weight: 500,
+          },
+        },
       },
-      formatter: (value: number, context: { chart: Chart; dataIndex: number }) => {
-        const label = context.chart.data.labels?.[context.dataIndex] ?? '';
-        return `${label}: ${value}`; // Affiche le label et la valeur
+      datalabels: {
+        display: false,
       },
-      anchor: 'end',
-      align: 'end',
-      offset: 10,
-      backgroundColor: 'rgba(255,255,255,0.8)',
-      borderRadius: 6,
-      padding: 4,
-    },
       tooltip: {
         callbacks: {
           label: (context: TooltipItem<'pie'>) => {
             const label = context.label ?? '';
             return `${label}: ${context.raw} medals`;
           },
         },
       },
     },
   };
 
+  private readonly calloutLabelsPlugin: Plugin<'pie'> = {
+    id: 'pieCalloutLabels',
+    afterDatasetsDraw: (chart) => {
+      const { ctx, data } = chart;
+      const dataset = data.datasets[0];
+      const meta = chart.getDatasetMeta(0);
+
+      if (!dataset || !meta?.data.length) {
+        return;
+      }
+
+      meta.data.forEach((element, index) => {
+        const {
+          x: centerX,
+          y: centerY,
+          startAngle,
+          endAngle,
+          outerRadius,
+        } = element.getProps(['x', 'y', 'startAngle', 'endAngle', 'outerRadius'], true);
+
+        const value = Number(dataset.data[index]);
+
+        if (!value) {
+          return;
+        }
+
+        const angle = (startAngle + endAngle) / 2;
+        const radialGap = 18;
+        const horizontalGap = 36;
+        const startX = centerX + Math.cos(angle) * outerRadius;
+        const startY = centerY + Math.sin(angle) * outerRadius;
+        const middleX = centerX + Math.cos(angle) * (outerRadius + radialGap);
+        const middleY = centerY + Math.sin(angle) * (outerRadius + radialGap);
+        const isRightSide = Math.cos(angle) >= 0;
+        const endX = middleX + (isRightSide ? horizontalGap : -horizontalGap);
+        const endY = middleY;
+
+        ctx.save();
+        ctx.beginPath();
+        ctx.moveTo(startX, startY);
+        ctx.lineTo(middleX, middleY);
+        ctx.lineTo(endX, endY);
+        const backgroundColors = dataset.backgroundColor ?? [];
+        const segmentColor = Array.isArray(backgroundColors)
+          ? (backgroundColors[index] as string | undefined)
+          : (backgroundColors as string | undefined);
+        ctx.strokeStyle = segmentColor ?? '#94a3b8';
+        ctx.lineWidth = 2;
+        ctx.stroke();
+
+        const label = data.labels?.[index] ?? '';
+        const valueText = `${value}`;
+        const textAlign = isRightSide ? 'left' : 'right';
+        const textX = endX + (isRightSide ? 12 : -12);
+
+        ctx.textAlign = textAlign;
+
+        ctx.font = "600 13px 'Poppins', 'Segoe UI', Arial, sans-serif";
+        ctx.fillStyle = '#0f172a';
+        ctx.textBaseline = 'bottom';
+        ctx.fillText(label, textX, endY - 2);
+
+        ctx.font = "500 12px 'Poppins', 'Segoe UI', Arial, sans-serif";
+        ctx.fillStyle = '#475569';
+        ctx.textBaseline = 'top';
+        ctx.fillText(valueText, textX, endY + 2);
+        ctx.restore();
+      });
+    },
+  };
+
   constructor(
     private readonly olympicService: OlympicService,
     private readonly router: Router
   ) {}
 
-  ngOnInit(): void 
+  ngOnInit(): void
   {
-    Chart.register(ChartDataLabels);
+    Chart.register(ChartDataLabels, this.calloutLabelsPlugin);
 
     this.olympics$ = this.olympicService.getOlympics();
     this.viewModel$ = this.olympics$.pipe(
       filter((olympics): olympics is OlympicCountry[] => Array.isArray(olympics)),
       map((olympics) => {
         const countriesCount = olympics.length;
         const olympicsCount = olympics.reduce(
           (total, country) => total + country.participations.length,
           0
         );
         const chartLabels = olympics.map((country) => country.country);
         const chartData = olympics.map((country) =>
           country.participations.reduce(
             (medalSum, participation) => medalSum + participation.medalsCount,
             0
           )
         );
         return {
           countriesCount,
           olympicsCount,
           chartData: {
             labels: chartLabels,
             datasets: [
               {
                 data: chartData,
 
EOF
)